
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build with AI on Android Session 1 - MediaPipe 활용하기</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="mediapipe_face_stylizer_android"
                  title="Build with AI on Android Session 1 - MediaPipe 활용하기"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Build with AI 캠페인 크래딧 등록" duration="0">
        <p>여러분의 참가자분들이 별도의 결제 수단(예: 신용카드) 등록 없이 Google Cloud Platform을 무료로 사용할 수 있도록, 아래 링크를 제공합니다.<br>Google 계정으로 회원가입하고 Free Tier를 활성화하는 방법은 [별도 안내 자료(Deck)](첨부 예정)에서 확인할 수 있습니다.</p>
<p><a href="https://trygcp.dev/e/build-ai-KRA01" target="_blank"><paper-button class="colored" raised>캠페인 크래딧 받으러 가기</paper-button></a>   <a href="https://docs.google.com/presentation/d/1fnQNauWcxgt5eqhTAuaBGn2giNQU6f_f_fv3R7nAvp4/edit?usp=sharing&resourcekey=0-dlnAU4LYN8QV27uVMLeIQA" target="_blank"><paper-button class="colored" raised>캠페인 등록 방법 가이드</paper-button></a> </p>
<p><strong>중요:</strong></p>
<ul>
<li>이 링크는 반드시 <strong>행사 당일, 워크숍 시간 중에만</strong> 참가자들에게 공유해 주세요.</li>
<li>링크를 미리 공개하거나 사전에 배포하지 말아 주세요.<br></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Introduction" duration="5">
        <p><strong>Last Updated:</strong> 2025-04-26</p>
<h2 is-upgraded><strong>1.1 MediaPipe 소개</strong></h2>
<p><a href="https://developers.google.com/mediapipe/solutions/guide?hl=ko" target="_blank">MediaPipe 솔루션</a>을 사용하면 머신러닝(ML) 솔루션을 앱에 적용할 수 있습니다. 이 솔루션으로 제공되는 프레임워크를 통해 사용자에게 즉각적이고, 매력적이고, 유용한 출력을 제공하는 사전 빌드된 처리 파이프라인을 구성할 수 있습니다. <a href="https://developers.google.com/mediapipe/solutions/model_maker?hl=ko" target="_blank">MediaPipe Model Maker</a>를 사용해서 이러한 솔루션을 맞춤설정하여 기본 모델을 업데이트할 수도 있습니다.</p>
<h3 is-upgraded><strong>주요 특징</strong></h3>
<ul>
<li><strong>온디바이스(on-device) 실행<br></strong> 서버에 요청을 보내지 않고, 디바이스 내에서 직접 스타일 변환 처리가 이루어집니다.<br> → 빠른 반응속도, 뛰어난 개인정보 보호<br></li>
<li><strong>고속 경량 모델<br></strong> 모바일 환경에 최적화되어 있어, 리소스 소모가 적고 실시간 변환이 가능합니다.<br></li>
<li><strong>다양한 스타일 지원<br></strong> Mediapipe 기본 모델에는 여러 스타일 프리셋이 포함되어 있으며,<br> 필요하면 커스텀 스타일로 모델을 재학습할 수도 있습니다.</li>
</ul>
<p class="image-container"><img style="width: 624.00px" src="img/dc51547d47a30881.png"></p>
<p>다음 라이브러리와 리소스는 각 MediaPipe 솔루션의 핵심 기능을 제공합니다.</p>
<ul>
<li><strong>MediaPipe Tasks</strong>: 솔루션을 배포하기 위한 크로스 플랫폼 API 및 라이브러리입니다. <a href="https://ai.google.dev/edge/mediapipe/solutions/tasks?hl=ko" target="_blank">자세히 알아보기</a></li>
<li><strong>MediaPipe 모델</strong>: 각 솔루션과 함께 사용할 수 있는 선행 학습된 실행 준비 상태의 모델입니다.</li>
</ul>
<p>다음 도구를 사용하여 솔루션을 맞춤설정하고 평가할 수 있습니다.</p>
<ul>
<li><strong>MediaPipe Model Maker</strong>: 데이터를 사용하여 솔루션용 모델을 맞춤설정합니다. <a href="https://ai.google.dev/edge/mediapipe/solutions/model_maker?hl=ko" target="_blank">자세히 알아보기</a></li>
<li><strong>MediaPipe 스튜디오</strong>: 브라우저에서 솔루션을 시각화, 평가, 벤치마킹합니다. <a href="https://ai.google.dev/edge/mediapipe/solutions/studio?hl=ko" target="_blank">자세히 알아보기</a></li>
</ul>
<h2 is-upgraded><strong>1.2 MediaPipe Studio</strong></h2>
<p>MediaPipe Studio를 이용하면 Android 디바이스 없이도, 브라우저에서 바로 다양한 솔루션(예: 얼굴 스타일 변환, 객체 감지, 손 랜드마크 감지 등)을 테스트할 수 있습니다.</p>
<p>➔ MediaPipe Studio로 이동해서 데모 체험하기: <a href="https://mediapipe-studio.webapps.google.com/home" target="_blank">https://mediapipe-studio.webapps.google.com/home</a></p>
<p class="image-container"><img style="width: 624.00px" src="img/50fb106841a6d5ab.png"></p>
<h2 is-upgraded>1.3 학습할 내용</h2>
<p>이 Codelab에서는 비어 있는 프로젝트로 시작하여 <a href="https://developers.google.com/mediapipe/solutions/tasks?hl=ko" target="_blank">MediaPipe 태스크</a>를 사용하여 Android 기기에서 로컬로 실행되는  &#34;얼굴 스타일 지정 (Face Stylizer)&#34; 솔루션을 직접 적용하는 방법을 배워봅니다.</p>
<h2 is-upgraded>1.4 <a href="https://ai.google.dev/edge/mediapipe/solutions/setup_android?hl=ko" target="_blank">필요한 항목</a></h2>
<ul>
<li><a href="https://developer.android.com/studio/index.html?hl=ko" target="_blank">Android 스튜디오</a> 2021.1.1 (Bumblebee) 이상 권장 버전 또는 호환되는 다른 버전 지원합니다.</li>
<li>Android SDK 버전 24 이상</li>
<li>최소 SDK 버전 이상의 Android 기기 Android Emulator 일부 태스크에는 작동하지 않을 수 있습니다.</li>
</ul>
<h2 is-upgraded>1.5 <strong> 안내: Android SDK 기본 구현 범위 제외</strong></h2>
<p>이 코드랩은 <strong>MediaPipe Face Stylizer 기능을 Android 앱에 통합하는 실습</strong>을 중심으로 구성되어 있습니다.</p>
<ul>
<li>Android Studio 설치, 새로운 프로젝트 생성, 기본적인 Compose 컴포넌트 작성 등<br></li>
<li><strong>Android SDK 및 Compose 기본 문법과 구현 방법</strong>은 별도로 설명하지 않습니다.<br></li>
</ul>
<p><strong>참여 대상:</strong> Android Studio와 Kotlin/Compose 기본 사용법에 익숙한 개발자</p>
<p>만약 Android SDK나 Compose 기초가 필요하다면, 다음 공식 자료를 참고하세요:</p>
<ul>
<li><a href="https://developer.android.com/guide" target="_blank">Android Developers 공식 가이드<br></a></li>
<li><a href="https://developer.android.com/jetpack/compose/documentation" target="_blank">Jetpack Compose 공식 문서</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Face stylizer 개요" duration="5">
        <aside class="warning"><p><strong>주의:</strong> MediaPipe Face Stylizer 작업은 실험용이며 현재 개발 중입니다.</p>
</aside>
<p>MediaPipe Face Stylizer 작업을 사용하면 이미지의 얼굴에 얼굴 스타일 지정을 적용할 수 있습니다. 이 태스크를 사용하여 다양한 스타일의 가상 아바타를 만들 수 있습니다.</p>
<p><a href="https://mediapipe-studio.webapps.google.com/studio/demo/face_stylizer?hl=ko" target="_blank"><paper-button class="colored" raised>사용해보기</paper-button></a></p>
<p class="image-container"><img style="width: 312.00px" src="img/842c9111bf9c59b0.png"></p>
<h2 is-upgraded><strong>2.1 모델</strong></h2>
<p>이 작업에서는 얼굴 생성기와 얼굴 인코더로 구성된 BlazeFaceStylizer 모델을 사용합니다. <a href="https://arxiv.org/abs/1812.04948" target="_blank">StyleGAN</a> 모델 제품군의 경량 구현인 BlazeStyleGAN 얼굴 생성기는 지정된 스타일에 따라 얼굴을 생성하고 수정합니다. <a href="https://arxiv.org/abs/1801.04381" target="_blank">MobileNet V2</a> 백본을 사용하는 얼굴 인코더는 입력 이미지를 얼굴 생성기에서 생성한 얼굴에 매핑합니다. 얼굴 스타일라이저를 사용하려면 얼굴 스타일 지정 모델을 다운로드하여 프로젝트 디렉터리에 저장해야 합니다. 각 모델은 입력 이미지 내 얼굴에 특정 스타일을 적용하도록 학습되었습니다.</p>
<aside class="warning"><p><strong>참고:</strong> 이 태스크는 제공된 ML 모델과 맞춤 모델의 수정을 지원합니다. 이 작업에 수정된 모델 또는 맞춤 모델을 사용하는 방법에 관한 자세한 내용은 <a href="https://ai.google.dev/edge/mediapipe/solutions/customization/face_stylizer?hl=ko" target="_blank">맞춤설정 가이드</a>를 참고하세요.</p>
</aside>
<h3 is-upgraded><strong>색상 스케치</strong></h3>
<p>이 모델은 얼굴을 색연필 획과 브러시 획으로 스케치를 모방한 이미지로 변환합니다. 이 모델을 학습하는 데 사용되는 스타일은 아래와 같습니다.</p>
<h2 is-upgraded><img alt="컬러 스케치 출력" style="width: 287.04px" src="img/af41e86a1c0daf35.png"></h2>
<table>
<tr><td colspan="1" rowspan="1"><p>모델 이름</p>
</td><td colspan="1" rowspan="1"><p>입력 셰이프</p>
</td><td colspan="1" rowspan="1"><p>양자화 유형</p>
</td><td colspan="1" rowspan="1"><p>버전</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><a href="https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_color_sketch.task" target="_blank">컬러 스케치</a></p>
</td><td colspan="1" rowspan="1"><p>256 x 256 x 3</p>
</td><td colspan="1" rowspan="1"><p>Float32</p>
</td><td colspan="1" rowspan="1"><p><a href="https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_color_sketch.task" target="_blank">최신</a></p>
</td></tr>
</table>
<h3 is-upgraded><strong>컬러 잉크</strong></h3>
<p>이 모델은 얼굴을 수채화 그림을 모방한 이미지로 변환합니다. 이 모델을 학습하는 데 사용되는 스타일은 아래와 같습니다.</p>
<h2 is-upgraded><img alt="컬러 잉크 출력" style="width: 288.00px" src="img/e6898e872b6e08fc.png"></h2>
<table>
<tr><td colspan="1" rowspan="1"><p>모델 이름</p>
</td><td colspan="1" rowspan="1"><p>입력 셰이프</p>
</td><td colspan="1" rowspan="1"><p>양자화 유형</p>
</td><td colspan="1" rowspan="1"><p>버전</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><a href="https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_color_ink.task" target="_blank">컬러 잉크</a></p>
</td><td colspan="1" rowspan="1"><p>256 x 256 x 3</p>
</td><td colspan="1" rowspan="1"><p>Float32</p>
</td><td colspan="1" rowspan="1"><p><a href="https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_color_ink.task" target="_blank">최신</a></p>
</td></tr>
</table>
<h3 is-upgraded><strong>유화</strong></h3>
<p>이 모델은 얼굴을 유화를 모방한 이미지로 변환합니다. 이 모델을 학습하는 데 사용되는 스타일은 아래와 같습니다.</p>
<h2 is-upgraded><img alt="유화 출력" style="width: 288.00px" src="img/41392e1af5a325e.png"></h2>
<table>
<tr><td colspan="1" rowspan="1"><p>모델 이름</p>
</td><td colspan="1" rowspan="1"><p>입력 셰이프</p>
</td><td colspan="1" rowspan="1"><p>양자화 유형</p>
</td><td colspan="1" rowspan="1"><p>버전</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><a href="https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_oil_painting.task" target="_blank">유화</a></p>
</td><td colspan="1" rowspan="1"><p>256 x 256 x 3</p>
</td><td colspan="1" rowspan="1"><p>Float32</p>
</td><td colspan="1" rowspan="1"><p><a href="https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_oil_painting.task" target="_blank">최신</a></p>
</td></tr>
</table>
<h2 is-upgraded><strong>2.2 Face Stylizer 동작 흐름 요약</strong></h2>
<ol type="1" start="1">
<li><strong>이미지 입력 : </strong>갤러리 선택<br></li>
<li><strong>얼굴 검출 및 스타일 변환 : </strong>Mediapipe Tasks API를 통해 얼굴을 인식하고 스타일을 적용<br></li>
<li><strong>스타일링된 이미지 출력 : </strong>변환 결과를 화면으로 실시간 표시</li>
</ol>
<h2 is-upgraded><strong>2.3 참고: 공식 샘플 코드</strong></h2>
<p>Face Stylizer는 Mediapipe 공식 GitHub에서도 Android 샘플 프로젝트를 제공합니다.<br> 실습 중 참고하거나 추가 학습을 원할 경우, 다음 링크를 활용할 수 있습니다.</p>
<p>👉<a href="https://github.com/google-ai-edge/mediapipe-samples/tree/main/examples/face_stylizer/android" target="_blank">공식 Mediapipe Face Stylizer Android 샘플 코드</a></p>
<p class="image-container"><img style="width: 328.60px" src="img/15cfe78d7b6255c4.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Android Project 생성" duration="10">
        <h2 is-upgraded><strong>3.1 Android Studio 준비</strong></h2>
<p>이 코드랩에서는 Android Studio를 사용하여 Compose 기반 Android 프로젝트를 생성합니다.</p>
<h3 is-upgraded><strong>필수 개발 환경</strong></h3>
<ul>
<li>Android Studio <strong>Giraffe</strong> 이상 (권장: <strong>Narwhal Canary 7</strong> 이상)<br></li>
<li>Kotlin 버전 <strong>1.9.22</strong> 이상<br></li>
<li>Android SDK API Level <strong>24</strong> 이상<br></li>
<li>테스트용 실제 디바이스 (에뮬레이터도 가능하지만, 일부 기능이 동작하지 않을 수 있습니다.)<br></li>
</ul>
<aside class="special"><p><strong>Tip </strong>Narwhal Canary 버전은 Gemini Assistant 이미지 기능도 함께 지원하므로, 최신 버전을 사용하는 것을 추천합니다.</p>
</aside>
<h2 is-upgraded><strong>3.2 새 Android 프로젝트 만들기</strong></h2>
<ol type="1" start="1">
<li><strong>Android Studio</strong>를 열고 <strong>New Project</strong>를 선택합니다.<br></li>
<li>템플릿으로 <strong>Empty Compose Activity</strong>를 선택합니다.<br></li>
<li>프로젝트 정보를 다음과 같이 설정합니다</li>
<li>Finish를 눌러 프로젝트를 생성합니다.<br></li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>항목</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>설정 값</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Name</p>
</td><td colspan="1" rowspan="1"><p>FaceStylizerApp</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Package Name</p>
</td><td colspan="1" rowspan="1"><p>원하는 이름 사용 (예: com.example.facestylizer)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Language</p>
</td><td colspan="1" rowspan="1"><p>Kotlin</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Minimum SDK</p>
</td><td colspan="1" rowspan="1"><p>API 24 이상</p>
</td></tr>
</table>
<h2 is-upgraded><strong>3.3 Gradle 설정</strong></h2>
<h3 is-upgraded><strong>build.gradle (app)</strong></h3>
<pre><code>dependencies {
    // MediaPipe Tasks Android 라이브러리 추가
    implementation &#39;com.google.mediapipe:tasks-vision:0.10.14&#39; 
    // // 이미지 표시
    implementation &#34;io.coil-kt:coil-compose:2.7.0&#34;
}</code></pre>
<aside class="special"><p><strong>참고: </strong>MediaPipe Tasks는 <strong>tasks-vision</strong> 패키지를 통해 Vision 관련 Task (Face Stylizer 포함)를 제공합니다.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="입력 이미지 선택 (갤러리)" duration="15">
        <p>Face Stylizer를 적용하려면 먼저 사용자의 얼굴 이미지를 준비해야 합니다.</p>
<p>이 단계에서는 <strong>갤러리에서 이미지를 선택하는 기능</strong>을 구현합니다.</p>
<h2 is-upgraded><strong>4.1 갤러리 열기 및 사진 선택</strong></h2>
<p><code>GalleryPicker.kt</code> 클래스를 새로 생성해 줍니다.</p>
<h3 is-upgraded><strong>GalleryPicker.kt</strong></h3>
<pre><code>import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.activity.result.PickVisualMediaRequest

@Composable
fun GalleryPicker(
   onImageSelected: (Uri) -&gt; Unit
) {
   val launcher = rememberLauncherForActivityResult(
       contract = ActivityResultContracts.PickVisualMedia()
   ) { uri: Uri? -&gt;
       uri?.let { onImageSelected(it) }
   }

   Box(
       modifier = Modifier.fillMaxWidth(),
       contentAlignment = Alignment.TopCenter
   ) {
       Button(onClick = {
           launcher.launch(
               PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
           )
       }) {
           Text(text = &#34;갤러리에서 이미지 선택&#34;)
       }
   }
}</code></pre>
<p>이 코드랩에서는 <a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.PickVisualMedia" target="_blank"><strong>ActivityResultContracts.PickVisualMedia()</strong></a> API를 사용하여 사진 선택기를 호출합니다. 사용자는 시스템 Photo Picker 화면에서 직접 사진을 선택하거나 취소할 수 있습니다. 사진 선택 도구 코드에 대해서 자세 알고 싶다면 다음 <a href="https://developer.android.com/training/data-storage/shared/photopicker?hl=ko" target="_blank">링크</a>를 참조하세요.</p>
<p>GalleryPicker 를 사용해 이미지를 표시해줄 MainScreen 을 만들어 줍니다. </p>
<h3 is-upgraded><strong>MainScreen.kt</strong></h3>
<pre><code>import android.net.Uri
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage


@Composable
fun MainScreen(
   modifier: Modifier = Modifier
) {
   var selectedImageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }

   Column(
       modifier = modifier
           .fillMaxSize(),
       verticalArrangement = Arrangement.spacedBy(16.dp)
   ) {
       // 갤러리 열기 버튼
       GalleryPicker(
           onImageSelected = { uri -&gt;
               selectedImageUri = uri
           }
       )

       // 선택한 이미지 표시
       selectedImageUri?.let { uri -&gt;
           AsyncImage(
               model = uri,
               contentDescription = &#34;Selected Image&#34;,
               modifier = Modifier
                   .fillMaxWidth()
                   .aspectRatio(1f)
           )
       }
   }
}</code></pre>
<h2 is-upgraded><strong>4.2 중간 실행 결과 </strong></h2>
<p>앱을 실행해서 사진이 잘 선택 되는 지 확인합니다. </p>
<p class="image-container"><img style="width: 284.21px" src="img/4a5d223f5de58513.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Face Stylizer Task 적용" duration="25">
        <p>이제 갤러리에서 선택한 이미지를 Mediapipe Face Stylizer를 통해 변환하는 기능을 구현합니다. 이 단계에서는 Mediapipe Tasks SDK를 이용해 Face Stylizer를 초기화하고, 선택한 이미지를 스타일링한 결과를 Compose 화면에 표시합니다.</p>
<h2 is-upgraded><strong>5.1 Mediapipe Tasks 라이브러리 준비 확인</strong></h2>
<p>이전 3.3 Gradle 설정에서 다음 의존성을 추가했는지 다시 확인합니다</p>
<h3 is-upgraded><strong>build.gradle</strong></h3>
<pre><code>dependencies {
    implementation &#39;com.google.mediapipe:tasks-vision:0.10.14&#39;
}</code></pre>
<h2 is-upgraded><strong>5.2 모델 다운로드 스크립트 만들기</strong></h2>
<p>App 모듈 하단에 <code>download_models.gradle</code> 파일을 생성합니다. </p>
<h3 is-upgraded><strong>download_model.gradle</strong></h3>
<pre><code>/*
* Copyright 2023 The TensorFlow Authors. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*             http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

//모델 다운로드 task 정의 
tasks.register(&#39;downloadColorInkTask&#39;, Download) {
   src &#39;https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_color_ink.task&#39;
   dest project.ext.ASSET_DIR + &#39;/face_stylizer_color_ink.task&#39;
   overwrite false
}

tasks.register(&#39;downloadColorSketchTask&#39;, Download) {
   src &#39;https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_color_sketch.task&#39;
   dest project.ext.ASSET_DIR + &#39;/face_stylizer_color_sketch.task&#39;
   overwrite false
}

tasks.register(&#39;downloadOilPainting&#39;, Download) {
   src &#39;https://storage.googleapis.com/mediapipe-models/face_stylizer/blaze_face_stylizer/float32/latest/face_stylizer_oil_painting.task&#39;
   dest project.ext.ASSET_DIR + &#39;/face_stylizer_oil_painting.task&#39;
   overwrite false
}

// 빌드 전에 모델 다운로드 
preBuild.dependsOn downloadColorInkTask, downloadColorSketchTask, downloadOilPainting
</code></pre>
<p><code>app/build.gradle</code> 파일에서 <code>asset</code> 디렉토리 경로를 설정하고 모델 다운로드 스크립트를 가져옵니다.</p>
<h3 is-upgraded><strong>app/build.gradle 파일 수정</strong></h3>
<pre><code>plugins {
   // 모델 다운로드를 위해 추가
   id(&#34;de.undercouch.download&#34;)
}


// import DownloadModels task
extra[&#34;ASSET_DIR&#34;] = &#34;${projectDir}/src/main/assets&#34;
extra[&#34;TEST_ASSETS_DIR&#34;] = &#34;${projectDir}/src/androidTest/assets&#34;

// Download default models; if you wish to use your own models then
// place them in the &#34;assets&#34; directory and comment out this line.
apply(from = &#34;download_models.gradle&#34;)


// 기존에 추가한 부분
dependencies {
    implementation &#39;com.google.mediapipe:tasks-vision:0.10.14&#39;
}</code></pre>
<h3 is-upgraded><strong>최상위 build.gradle</strong></h3>
<pre><code>buildscript {
   dependencies {
       classpath(&#34;de.undercouch:gradle-download-task:5.6.0&#34;)
   }
}</code></pre>
<p>여기까지 추가하고 앱을 실행해주면, 앱이 빌드하면서 자동으로 <code>main</code> 밑에 <code>asset</code> 폴더를 만들고 <code>download_models.gradle</code> 스크립트에서 선언해준 기존 <code>task</code> 를 다운로드 받습니다. </p>
<h3 is-upgraded><strong>assets 디렉토리 구조</strong></h3>
<pre><code>app/
 └─ src/
     └─ main/
         └─ assets/
             └─ face_stylizer.task</code></pre>
<p class="image-container"><img style="width: 355.50px" src="img/3227e4f23a1538b7.png"></p>
<h2 is-upgraded>5.3 <strong>FaceStylizationHelper</strong></h2>
<p><code>FaceStylizationHelper</code> 클래스는 <strong>MediaPipe Face Stylizer</strong> 모델을 Android 앱에 쉽게 통합하기 위해 설계된 <strong>도우미(Helper)</strong> 클래스입니다.</p>
<p>이 클래스는 다음과 같은 기능을 제공합니다:</p>
<ul>
<li>선택한 스타일 모델로 <strong>FaceStylizer 초기화</strong></li>
<li>입력된 <strong>Bitmap 이미지를 스타일 변환</strong></li>
<li><strong>처리 시간(inference time)</strong> 을 측정하여 성능 분석 지원</li>
<li>변환 실패 시 <strong>오류 콜백</strong> 제공</li>
<li>리소스 관리(초기화 및 해제)<br></li>
</ul>
<p>FaceStylizationHelper를 사용하면 복잡한 설정 과정을 직접 관리하지 않고, 간단한 API 호출만으로 스타일 변환 기능을 손쉽게 구현할 수 있습니다.</p>
<p>공식 예제에 있는 클래스를 그대로 활용합니다. </p>
<h3 is-upgraded><strong>FaceStylizationHelper.kt</strong></h3>
<pre><code>import android.content.Context
import android.graphics.Bitmap
import android.util.Log
import com.google.mediapipe.framework.image.BitmapImageBuilder
import com.google.mediapipe.tasks.core.BaseOptions
import com.google.mediapipe.tasks.vision.facestylizer.FaceStylizer
import com.google.mediapipe.tasks.vision.facestylizer.FaceStylizer.FaceStylizerOptions
import com.google.mediapipe.tasks.vision.facestylizer.FaceStylizerResult

class FaceStylizationHelper(
   private val modelPosition: Int,
   private val context: Context,
   var faceStylizerListener: FaceStylizerListener? = null
) {

   private var faceStylizer: FaceStylizer? = null

   init {
       setupFaceStylizer()
   }

   /**
    * FaceStylizer를 초기화합니다.
    * 선택된 modelPosition에 따라 다른 모델 파일을 로드합니다.
    */
   private fun setupFaceStylizer() {
       val baseOptionsBuilder = BaseOptions.builder()
       // Sets the model selection.
       baseOptionsBuilder.setModelAssetPath(
           when (modelPosition) {
               0 -&gt; MODEL_PATH_COLOR_SKETCH
               1 -&gt; MODEL_PATH_COLOR_INK
               2 -&gt; MODEL_PATH_OIL_PAINTING
               else -&gt; throw Throwable(&#34;Invalid model type position&#34;)
           }
       )

       try {
           // 옵션 빌드 및 FaceStylizer 인스턴스 생성
           val baseOptions = baseOptionsBuilder.build()
           val optionsBuilder = FaceStylizerOptions.builder()
               .setBaseOptions(baseOptions)

           val options = optionsBuilder.build()
           faceStylizer = FaceStylizer.createFromOptions(context, options)
       } catch (e: IllegalStateException) {
           // 일반적인 초기화 오류 처리
           faceStylizerListener?.onError(
               &#34;Face stylizer failed to initialize. See error logs for &#34; +
                       &#34;details&#34;
           )
           Log.e(
               TAG,
               &#34;Face stylizer failed to load model with error: &#34; + e.message
           )
       } catch (e: RuntimeException) {
           // GPU 미지원 기기에서 발생할 수 있는 오류 처리
           // This occurs if the model being used does not support GPU
           faceStylizerListener?.onError(
               &#34;Face stylizer failed to initialize. See error logs for &#34; +
                       &#34;details&#34;, GPU_ERROR
           )
           Log.e(
               TAG,
               &#34;Face stylizer failed to load model with error: &#34; + e.message
           )
       }
   }

   /**
    * 주어진 Bitmap을 스타일 변환하여 결과를 반환합니다.
    * - 변환 시간(inference time)을 함께 측정합니다.
    */
   fun stylize(bitmap: Bitmap): ResultBundle {
       val mpImage = BitmapImageBuilder(bitmap).build()
       var timestampMs = System.currentTimeMillis()
       val result = faceStylizer?.stylize(mpImage)
       timestampMs = System.currentTimeMillis() - timestampMs

       return ResultBundle(result, timestampMs)
   }

   /**
    * 스타일링 결과를 Bitmap으로 변환합니다.
    *
    * @param result 스타일링된 얼굴 정보와 추론 시간을 포함한 ResultBundle
    * @return 스타일링된 얼굴 이미지의 Bitmap, 또는 스타일링 결과가 없는 경우 null
    */
    @OptIn(ExperimentalStdlibApi::class)
    fun convertStylizedFaceToBitmap(result: ResultBundle): Bitmap? {
       // 결과가 없거나 스타일링된 이미지가 없는 경우 null 반환
       if (result.stylizedFace == null ||     result.stylizedFace.stylizedImage().getOrNull() == null) {
           return null
       }

       // 스타일링된 얼굴 이미지 정보 가져오기
       val image = result.stylizedFace
       // 이미지 데이터를 ByteBuffer로 추출
       val byteBuffer =     ByteBufferExtractor.extract(image.stylizedImage().get())

       // 이미지 크기 정보 가져오기
       val width = image.stylizedImage().get().width
       val height = image.stylizedImage().get().height

       // 추출한 정보로 새 Bitmap 생성
       val bitmap = createBitmap(width, height)
       // ByteBuffer의 픽셀 데이터를 Bitmap에 복사
       bitmap.copyPixelsFromBuffer(byteBuffer)
       return bitmap
    }


   /**
    * 사용이 끝난 후 FaceStylizer 리소스를 해제합니다.
    */
   fun close() {
       faceStylizer?.close()
   }

   /**
    * 스타일링 결과와 처리 시간을 묶어 반환하는 데이터 클래스입니다.
    */
   data class ResultBundle(
       val stylizedFace: FaceStylizerResult?, // 스타일링된 결과 (FaceStylizerResult)
       val inferenceTime: Long,  // 처리 소요 시간 (ms 단위)
   )

   companion object {
       // 모델 파일 경로 상수
       const val MODEL_PATH_OIL_PAINTING = &#34;face_stylizer_oil_painting.task&#34;
       const val MODEL_PATH_COLOR_INK = &#34;face_stylizer_color_ink.task&#34;
       const val MODEL_PATH_COLOR_SKETCH = &#34;face_stylizer_color_sketch.task&#34;
       const val OTHER_ERROR = 0
       const val GPU_ERROR = 1
       private const val TAG = &#34;FaceStylizationHelper&#34;
   }


   /**
    * FaceStylizer 오류 발생 시 호출되는 리스너 인터페이스
    */
   interface FaceStylizerListener {
       fun onError(error: String, errorCode: Int = OTHER_ERROR)
   }
}
</code></pre>
<h2 is-upgraded><strong>5.4 Helper 초기화하기 </strong></h2>
<p>FaceStylizerHelper 를 MainScreen 에서 사용하기 위해서 생성해서 넘겨줍니다.</p>
<h3 is-upgraded><strong>MainActivity.kt 수정</strong></h3>
<pre><code>class MainActivity : ComponentActivity() {

    private lateinit var faceStylizationHelper: FaceStylizationHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // TODO
        // Activity 레벨에서 Helper 생성
        faceStylizationHelper = FaceStylizationHelper(
            modelPosition = 0, // 기본 모델 포지션 설정 (예: Color Sketch)
            context = this,
            faceStylizerListener = object : FaceStylizationHelper.FaceStylizerListener {
                override fun onError(error: String, errorCode: Int) {
                    Log.e(&#34;MainActivity&#34;, &#34;FaceStylizer Error: $error (code: $errorCode)&#34;)
                    // 필요하면 Toast 띄우거나 UI 업데이트 가능
                }
            }
        )

        enableEdgeToEdge()

        setContent {
            FaceStylizerTestTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;
                    // TODO
                    // MainScreen에 helper를 넘긴다!
                    MainScreen(
                        modifier = Modifier.padding(innerPadding),
                        helper = faceStylizationHelper
                    )
                }
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        // Activity 종료 시 리소스 해제
        faceStylizationHelper.close()
    }
}</code></pre>
<h2 is-upgraded>5.4 이미지에 스타일 적용하기</h2>
<p>사용자가 갤러리에서 이미지를 선택 해서 &#34;스타일 적용하기&#34;를 클릭하면, </p>
<p>해당 이미지의 Uri를 가져와 Bitmap으로 변환한 후 </p>
<pre><code>val bitmap = loadBitmapFromUri(context, uri)

/**
* Helper 함수: Uri를 Bitmap으로 변환
*/
fun loadBitmapFromUri(context: Context, uri: Uri): Bitmap? {
   return try {
       context.contentResolver.openInputStream(uri)?.use {
           BitmapFactory.decodeStream(it)
       }
   } catch (e: Exception) {
       Log.e(&#34;MainScreen&#34;, &#34;Failed to load Bitmap from Uri&#34;, e)
       null
   }
}</code></pre>
<p>Face Stylizer helper 에 전달하는 코드를 생성해줍니다.</p>
<p>stylized 된 <code>result</code> 는 <code>convertStylizedFaceToBitmap(result)</code> 을 통해 스타일링 된 결과 값을 반환합니다.</p>
<pre><code> bitmap?.let {
    val result = helper.stylize(it)
    onStylized(helper.convertStylizedFaceToBitmap(result))
 }</code></pre>
<p>스타일 적용하기 버튼 전체 코드 </p>
<h3 is-upgraded><strong>StyleizeButton.kt</strong></h3>
<pre><code>@Composable
fun StylizeButton(
   uri: Uri,
   context: Context,
   helper: FaceStylizationHelper,
   onStylized: (Bitmap?) -&gt; Unit
) {
   Box(
       modifier = Modifier.fillMaxWidth(),
       contentAlignment = Alignment.TopCenter
   ) {
       Button(onClick = {
           val bitmap = loadBitmapFromUri(context, uri)
           bitmap?.let {
               val result = helper.stylize(it)
               onStylized(helper.convertStylizedFaceToBitmap(result))
           }
       }) {
           Text(text = &#34;스타일 적용하기&#34;)
       }
   }
}

/**
* Helper 함수: Uri를 Bitmap으로 변환
*/
fun loadBitmapFromUri(context: Context, uri: Uri): Bitmap? {
   return try {
       context.contentResolver.openInputStream(uri)?.use {
           BitmapFactory.decodeStream(it)
       }
   } catch (e: Exception) {
       Log.e(&#34;MainScreen&#34;, &#34;Failed to load Bitmap from Uri&#34;, e)
       null
   }
}</code></pre>
<h2 is-upgraded><strong>5.5 Compose 화면에 변환 결과 표시</strong></h2>
<p>Compose에서는 Image 컴포저블을 사용해 변환된 Bitmap을 바로 화면에 표시할 수 있습니다.</p>
<pre><code>@Composable
private fun StylizedImage(bitmap: Bitmap) {
   Image(
       bitmap = bitmap.asImageBitmap(),
       contentDescription = &#34;Stylized Image&#34;,
       modifier = Modifier
           .fillMaxWidth(0.8f) 
           .aspectRatio(1f)
   )
}</code></pre>
<p>asImageBitmap() 확장 함수를 사용하여 Bitmap을 Compose 이미지로 변환합니다.</p>
<h2 is-upgraded><strong>5.6 MainScreen 전체 코드 </strong></h2>
<p>화면에 보기좋게 맞추기 위해 일부 컴포넌트 modifier 값을 조정한 코드입니다. </p>
<h3 is-upgraded><strong>MainScreen.kt</strong></h3>
<pre><code>@Composable
fun MainScreen(
   modifier: Modifier = Modifier,
   helper: FaceStylizationHelper
) {
   var selectedImageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }
   var stylizedBitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }

   val context = LocalContext.current

   Column(
       modifier = modifier.fillMaxSize(),
       verticalArrangement = Arrangement.spacedBy(16.dp),
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       // 갤러리 열기 버튼
       GalleryPicker(
           onImageSelected = { uri -&gt;
               selectedImageUri = uri
           }
       )

       // 선택한 이미지 표시
       selectedImageUri?.let { uri -&gt;
           SelectedImage(uri)
          
           StylizeButton(
               uri = uri,
               context = context,
               helper = helper,
               onStylized = { stylizedBitmap = it }
           )

           // 스타일 적용된 이미지 표시
           stylizedBitmap?.let { styledBitmap -&gt;
               StylizedImage(styledBitmap)
           }
       }
   }
}

@Composable
private fun SelectedImage(uri: Uri) {
   AsyncImage(
       model = uri,
       contentDescription = &#34;Selected Image&#34;,
       modifier = Modifier
           .fillMaxWidth(0.8f) 
           .aspectRatio(1f)
   )
}

@Composable
private fun StylizedImage(bitmap: Bitmap) {
   Image(
       bitmap = bitmap.asImageBitmap(),
       contentDescription = &#34;Stylized Image&#34;,
       modifier = Modifier
           .fillMaxWidth(0.8f) 
           .aspectRatio(1f)
   )
}
</code></pre>
<h2 is-upgraded><strong>5.7 결과 확인</strong></h2>
<ul>
<li>화면 상단에는 <strong>선택한 원본 이미지</strong>가 표시됩니다.</li>
<li>화면 하단에는 <strong>스타일 변환된 결과 이미지</strong>가 표시됩니다.</li>
<li>원본과 결과를 직접 비교하며 스타일 효과를 확인할 수 있습니다.</li>
</ul>
<p class="image-container"><img style="width: 298.04px" src="img/302a35a205391914.png"></p>
<h2 is-upgraded><strong>5.8 [심화] 다양한 스타일 모델로 전환하기</strong></h2>
<p>MainActivity에서는 기본적으로 <strong>Color Sketch</strong> 스타일 모델을 사용하도록 설정되어 있습니다. 현재는 modelPosition = 0으로 고정되어 있으며, 앱을 실행하면 항상 &#34;Color Sketch&#34; 스타일로 변환됩니다.</p>
<h3 is-upgraded><strong>MainActivity.kt</strong></h3>
<pre><code>// Activity 레벨에서 Helper 생성
faceStylizationHelper = FaceStylizationHelper(
   modelPosition = 0, // 기본 모델 포지션 설정 (예: Color Sketch)
   context = this,
   faceStylizerListener = object : FaceStylizationHelper.FaceStylizerListener {
       override fun onError(error: String, errorCode: Int) {
           Log.e(&#34;MainActivity&#34;, &#34;FaceStylizer Error: $error (code: $errorCode)&#34;)
           // 필요하면 Toast 띄우거나 UI 업데이트 가능
       }
   }
)</code></pre>
<h2 is-upgraded><strong>✨ 심화 도전: 다양한 스타일 전환 기능 추가하기</strong></h2>
<p><strong>다양한 스타일을 선택해 바꾸는 기능</strong>은 Mediapipe 자체를 이해하는 것보다, 오히려 <strong>Compose 상태 관리, 리컴포지션 흐름</strong>을 활용하는 부분이 더 큰 비중을 차지합니다. 따라서, 이 부분은 &#34;심화&#34; 주제로 남겨두었습니다.</p>
<p>아래 목표를 스스로 구현해보세요!</p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>목표</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>설명</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1</p>
</td><td colspan="1" rowspan="1"><p>여러 스타일 모델을 선택할 수 있도록 UI를 추가하세요 (예: 드롭다운, 버튼 목록 등)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>2</p>
</td><td colspan="1" rowspan="1"><p>사용자가 모델을 선택하면, 해당 스타일 모델로 FaceStylizationHelper를 다시 초기화하세요</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>3</p>
</td><td colspan="1" rowspan="1"><p>새로운 스타일 모델을 적용한 후, 갤러리에서 선택한 이미지를 스타일링해보세요</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>4</p>
</td><td colspan="1" rowspan="1"><p>필요하다면 모델 변경 시, 현재 선택된 이미지를 자동으로 다시 스타일링하는 기능도 도전해보세요!</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="사용자 정의 스타일 학습" duration="20">
        <h2 is-upgraded><strong>6.1 개요</strong></h2>
<p>제공된 모델에서 지원하지 않는 새로운 스타일로 얼굴을 변환해야 하는 경우, 사전 학습된 모델을 사용자 데이터와 MediaPipe <a href="https://developers.google.com/mediapipe/solutions/model_maker" target="_blank">Model Maker를</a> 사용하여 맞춤 설정할 수 있습니다 . 이 모델 수정 도구는 사용자가 제공한 데이터를 사용하여 모델의 일부를 미세 조정합니다. 이 방법은 새 모델을 처음부터 학습하는 것보다 빠르며, 특정 애플리케이션에 맞게 모델을 조정할 수 있습니다.</p>
<p>다음 섹션에서는 Model Maker를 사용하여 미리 빌드된 모델을 얼굴 스타일 지정을 위해 사용자 데이터로 재학습하는 방법을 보여줍니다. 이 데이터는 MediaPipe <a href="https://developers.google.com/mediapipe/solutions/vision/face_stylizer" target="_blank">Face Stylizer</a> 에서 사용할 수 있습니다 .</p>
<p>MediaPipe Model Maker 패키지는 디바이스 내 머신 러닝(ML) 모델을 사용자 정의하기 위한 low-code 솔루션입니다.</p>
<p>이 노트북은 스타일화된 얼굴의 스타일을 실제 사람 얼굴로 전환하기 위해 얼굴 스타일라이저 모델을 사용자 지정하는 처음부터 끝까지의 프로세스를 보여줍니다.</p>
<p>모델 학습은 아래의 Colab 환경에서 진행합니다. </p>
<p><a href="https://colab.research.google.com/github/googlesamples/mediapipe/blob/main/examples/customization/face_stylizer.ipynb" target="_blank"><paper-button class="colored" raised>Colab 링크</paper-button></a></p>
<p><a href="https://ai.google.dev/edge/mediapipe/solutions/customization/face_stylizer" target="_blank"><paper-button class="colored" raised>모델학습 커스터마이징 가이드</paper-button></a></p>
<h2 is-upgraded><strong>6.2 설치 명령어 </strong></h2>
<pre><code>pip install mediapipe-model-maker</code></pre>
<p>다음 코드를 사용하여 필요한 Python 클래스를 가져옵니다.</p>
<pre><code>from google.colab import files
import os
import tensorflow as tf
assert tf.__version__.startswith(&#39;2&#39;)

from mediapipe_model_maker import face_stylizer
from mediapipe_model_maker import image_utils

import matplotlib.pyplot as plt</code></pre>
<h2 is-upgraded><strong>6.3 데이터 준비 및 검토 </strong></h2>
<p>얼굴 스타일라이저 모델을 재학습하려면 사용자가 스타일화된 얼굴 이미지 하나를 제공해야 합니다. 스타일화된 얼굴은 정면을 향하고 좌우 눈과 입이 모두 보이는 상태여야 합니다. 얼굴은 요, 피치, 롤 축을 기준으로 30도 미만의 미세한 회전만 있어야 합니다.</p>
<p>다음 예에서는 양식화된 얼굴 이미지를 제공하고 이미지를 시각화하는 방법을 보여줍니다.</p>
<pre><code>style_image_path = &#39;color_sketch.jpg&#39;
!wget -q -O {style_image_path} https://storage.googleapis.com/mediapipe-assets/face_stylizer_style_color_sketch.jpg</code></pre>
<pre><code># @title Visualize the training image
import cv2
from google.colab.patches import cv2_imshow

style_image_tensor = image_utils.load_image(style_image_path)
style_cv_image = cv2.cvtColor(style_image_tensor.numpy(), cv2.COLOR_RGB2BGR)
cv2_imshow(style_cv_image)</code></pre>
<h2 is-upgraded>6.4 데이터 세트 생성</h2>
<p>얼굴 스타일라이저 모델을 훈련하기 위해 단일 훈련 이미지를 래핑하는 데이터 세트를 만들어야 합니다.</p>
<p>데이터 세트를 생성하려면 Dataset.from_image 메서드를 사용하여 style_image_path에 있는 이미지를 로드합니다. 얼굴 스타일라이저는 단일 스타일 이미지만 지원합니다.</p>
<pre><code>data = face_stylizer.Dataset.from_image(filename=style_image_path)</code></pre>
<h2 is-upgraded><strong>6.5 모델 재학습</strong></h2>
<p>데이터 준비가 완료되면 얼굴 스타일러스 모델을 재학습하여 새로운 스타일에 적응시킬 수 있습니다. 이러한 모델 수정을 <a href="https://www.wikipedia.org/wiki/Transfer_learning" target="_blank">전이 학습</a> 이라고 합니다 . 아래 지침에서는 이전 섹션에서 준비한 데이터를 사용하여 얼굴 스타일러스 모델을 재학습하여 원본 사람 얼굴에 만화 스타일을 적용합니다.</p>
<aside class="warning"><p><strong>참고: </strong>이 유형의 모델의 경우, 재학습 과정에서 이전에 적용 가능했던 스타일이 모두 삭제됩니다. 재학습이 완료되면 새 모델은 새로 스타일이 적용된 이미지에 정의된 새 스타일 <em>만 적용할 수 있습니다.</em></p>
</aside>
<h3 is-upgraded><strong>재교육 옵션 설정</strong></h3>
<p>훈련 데이터 세트 외에 재훈련을 실행하려면 몇 가지 필수 설정이 있습니다.</p>
<ol type="1" start="1">
<li>모델 아키텍처: SupportedModels클래스를 사용하여 모델 아키텍처를 지정합니다. 지원되는 유일한 아키텍처는 face_stylizer.SupportedModels.BLAZE_FACE_STYLIZER_256 입니다.</li>
<li>스왑 레이어: 이 매개변수는 학습된 스타일과 원시 얼굴 이미지 사이의 잠재 코드 레이어를 혼합하는 방법을 결정하는 데 사용됩니다. 잠재 코드는 [1, 12, 512] 모양의 텐서로 표현됩니다. 잠재 코드 텐서의 두 번째 차원을 레이어라고 합니다. 얼굴 스타일라이저는 스왑 레이어에서 두 잠재 코드의 가중 합을 생성하여 학습된 스타일과 원시 얼굴 이미지를 혼합합니다. 따라서 스왑 레이어는 [1, 12] 내의 정수입니다. 레이어가 많이 설정될수록 출력 이미지에 더 많은 스타일이 적용됩니다. 스타일 의미론과 레이어 인덱스 간에 명시적인 매핑은 없지만 얕은 레이어(예: 8, 9)는 얼굴의 전역적 특징을 나타내는 반면 깊은 레이어(예: 10, 11)는 얼굴의 세밀한 특징을 나타냅니다. 출력 스타일화된 이미지는 스왑 레이어 설정에 따라 달라집니다. 기본적으로 [8, 9, 10, 11]로 설정됩니다. 사용자는 ModelOptions를 통해 설정할 수 있습니다.</li>
<li>학습률 및 에포크: HParams 객체 learning_rate와 epoch를 사용하여 두 하이퍼파라미터를 지정합니다. learning_rate는 기본적으로 4e-4로 설정됩니다. epochs는 BlazeStyleGAN 모델을 미세 조정하는 데 필요한 반복 횟수를 정의하며, 기본적으로 100으로 설정됩니다. 학습률이 낮을수록 모델을 수렴하도록 재학습하는 데 필요한 에포크 횟수가 늘어납니다.</li>
<li>배치 크기: HParams객체  batch_size를 사용하여 지정합니다. 배치 크기는 인코더가 입력 이미지에서 추출한 잠재 코드 주변에서 샘플링하는 잠재 코드 샘플 수를 정의하는 데 사용됩니다. 잠재 코드 배치는 디코더를 미세 조정하는 데 사용됩니다. 배치 크기가 클수록 일반적으로 성능이 향상됩니다. 또한 하드웨어 메모리에 의해 제한됩니다. A100 GPU의 경우 최대 배치 크기는 8입니다. P100 및 T4 GPU의 경우 최대 배치 크기는 2입니다.</li>
</ol>
<pre><code>face_stylizer_options = face_stylizer.FaceStylizerOptions(
  model=face_stylizer.SupportedModels.BLAZE_FACE_STYLIZER_256,
  model_options=face_stylizer.ModelOptions(swap_layers=[10,11]),
  hparams=face_stylizer.HParams(
      learning_rate=8e-4, epochs=200, batch_size=2, export_dir=&#34;exported_model&#34;
  )
)</code></pre>
<h3 is-upgraded><strong>재교육 실행</strong></h3>
<p>학습 데이터 세트와 재학습 옵션이 준비되었으므로 재학습 프로세스를 시작할 준비가 되었습니다. 이 프로세스는 GPU에서 실행되어야 하며, 사용 가능한 컴퓨팅 리소스에 따라 몇 분에서 몇 시간까지 걸릴 수 있습니다. GPU 런타임이 포함된 Google Colab 환경을 사용할 경우 아래 예시 재학습은 약 2분 정도 소요됩니다.</p>
<p>재교육 과정을 시작하려면 create()이전에 정의한 데이터 세트와 옵션을 사용하여 다음 방법을 사용하세요.</p>
<pre><code>face_stylizer_model = face_stylizer.FaceStylizer.create(
  train_data=data, options=face_stylizer_options
)</code></pre>
<h2 is-upgraded><strong>6.6 성과평가</strong></h2>
<p>모델을 재학습한 후, 입력 스타일 이미지의 재구성 결과에 대한 주관적인 평가를 수행할 수 있습니다. 스타일 이미지의 주요 스타일 특징과 사람 얼굴이 잘 재구성되면, 모델은 해당 스타일에 수렴하는 것으로 정의되며 다른 원본 얼굴 이미지에도 적용할 수 있습니다. 스타일 이미지를 재구성할 수 없거나 재구성된 스타일 이미지에서 상당한 아티팩트가 관찰되면, 입력 스타일이 얼굴 스타일라이저 모델에 적합하지 않을 수 있습니다.</p>
<p>예제 모델을 평가하려면 아래와 같이 입력 스타일 이미지에 대해 실행하세요.</p>
<pre><code>print(&#39;Input style image&#39;)
resized_style_cv_image = cv2.resize(style_cv_image, (256, 256))
cv2_imshow(resized_style_cv_image)

eval_output = face_stylizer_model.stylize(data)
eval_output_data = eval_output.gen_tf_dataset()
iterator = iter(eval_output_data)

reconstruct_style_image = (tf.squeeze(iterator.get_next()).numpy())
test_output_image = cv2.cvtColor(output_image, cv2.COLOR_RGB2BGR)
print(&#39;\nReconstructed style image&#39;)
cv2_imshow(test_output_image)</code></pre>
<aside class="warning"><p><strong>주의: </strong>머신 러닝 모델의 공통적인 목표는 모델의 높은 정확도를 달성하는 것이지만, 과적합 지점까지 학습시키지 않도록 주의해야 합니다 . <a href="https://en.wikipedia.org/wiki/Overfitting" target="_blank">과적합</a> 지점까지 학습 시키면 모델이 학습 데이터에서는 매우 좋은 성능을 보이지만, 새로운 데이터에서는 성능이 상당히 저하됩니다.</p>
</aside>
<h2 is-upgraded><strong>6.7 모델 내보내기</strong></h2>
<p>모델을 재학습한 후에는 애플리케이션의 MediaPipe와 함께 사용할 수 있도록 Tensorflow Lite 모델 형식으로 내보내야 합니다. 내보내기 과정에서 필요한 모델 메타데이터와 분류 레이블 파일이 생성됩니다.</p>
<p>애플리케이션에서 사용하기 위해 재학습된 모델을 내보내려면 다음 명령을 사용하세요.</p>
<pre><code>face_stylizer_model.export_model()</code></pre>
<p>Google Colab에서 다음 명령을 사용하여 모델을 나열하고 개발 환경에 다운로드하세요. 이 face_stylizer.task파일은 얼굴 스타일라이저 작업 라이브러리를 실행하는 데 필요한 세 개의 TFLite 모델로 구성되어 있습니다.</p>
<pre><code>!ls exported_model
files.download(&#39;exported_model/face_stylizer.task&#39;)</code></pre>
<h2 is-upgraded><strong>6.8 재교육 매개변수</strong></h2>
<p>재학습 프로세스 실행 방식을 추가로 사용자 지정하여 학습 시간을 조정하고 재학습된 모델의 성능을 잠재적으로 향상시킬 수 있습니다. <em>이러한 매개변수는 선택 사항입니다</em> . FaceStylizerOptions클래스와 HParams클래스를 사용하여 이러한 추가 옵션을 설정하세요.</p>
<p>클래스 매개변수를 사용하여 FaceStylizerModelOptions기존 모델을 사용자 정의할 수 있습니다. 모델 정확도에 영향을 미치는 다음과 같은 사용자 정의 매개변수가 있습니다.</p>
<ul>
<li>swap_layers: 0과 잠재 코드 레이어의 최대 레이어 인덱스 사이의 레이어 인덱스 집합입니다. 기본 BLAZE_FACE_STYLIZER_256의 잠재 코드 차원이 12이므로 는 swap_layers0과 11 사이여야 합니다. 이 하이퍼파라미터는 스타일 잠재 코드가 적용되는 레이어를 정의하여 원시 얼굴 특징과 보간합니다. 선택하는 레이어가 많을수록 적용되는 스타일 특징도 많아집니다. 레이어 인덱스와 의미 특징 간에는 명시적인 매핑이 없습니다. 사용자는 주관적인 평가를 통해 이러한 스왑 레이어를 미세 조정하여 최적의 옵션을 결정해야 합니다. 순서는 중요하지 않습니다.</li>
<li>alpha: 레이어 보간을 위한 스타일 잠재 가중치 계수입니다. 유효 범위는 [0, 1]입니다. 가중치가 높을수록 출력 이미지에 더 강한 스타일이 적용됩니다. 작은 값(예: &lt;0.1)으로 설정하는 것이 좋습니다.</li>
<li>perception_loss_weight: 이미지 인식 품질 손실의 가중 계수. 생성된 이미지와 원시 입력 이미지의 차이, 생성된 얼굴과 원시 입력 얼굴의 콘텐츠 차이, 그리고 생성된 이미지와 원시 입력 이미지의 스타일 유사도를 제어하는 ​​세 가지 계수, l1, content, 를 포함합니다. 사용자는 가중치를 높여 더 강력한 스타일을 적용하거나, 가중치를 높여 더 많은 원시 입력 얼굴 세부 정보를 보존할 수 있습니다.stylestylecontent</li>
<li>adv_loss_weight: 적대적 손실 대비 이미지 인지 품질 손실의 가중 계수. 이 하이퍼파라미터는 생성된 이미지의 사실성을 제어하는 ​​데 사용됩니다. 0.2 미만의 작은 값을 예상합니다.</li>
</ul>
<p>이 클래스를 사용하여 HParams모델의 학습 및 저장과 관련된 다른 매개변수를 사용자 정의합니다.</p>
<ul>
<li>learning_rate: 경사 하강법 학습에 사용할 학습률입니다. 기본값은 8e-4입니다.</li>
<li>batch_size: 학습을 위한 배치 크기입니다. 기본값은 4입니다.</li>
<li>epochs: 데이터 세트에 대한 학습 반복 횟수입니다. 기본값은 100입니다.</li>
<li>beta_1: tf.keras.optimizers.Adam에서 사용되는 beta_1입니다. 기본값은 0.0입니다.</li>
<li>beta_2: tf.keras.optimizers.Adam에서 사용되는 beta_2입니다. 기본값은 0.99입니다.</li>
</ul>
<h2 is-upgraded><strong>6.9 Android 앱에 통합</strong></h2>
<p>- <code>assets</code> 디렉토리에 <code>face_stylizer_custom.task</code> 파일 추가<br>- FaceStylizer 초기화 시 모델 경로를 새 파일로 지정:</p>
<h3 is-upgraded><strong>FaceStylizationHelper.kt</strong></h3>
<pre><code>val baseOptions = BaseOptions.builder()
    .setModelAssetPath(&#34;face_stylizer_custom.task&#34;)
    .build()</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="축하합니다!" duration="0">
        <p>Face Stylizer 앱을 처음부터 직접 만들어보고, 기본 모델 적용뿐 아니라 다양한 스타일 전환, 심지어 <strong>커스텀 모델</strong>까지 성공적으로 다루었습니다.</p>
<ul>
<li>Android Compose 기반의 갤러리 연동</li>
<li>MediaPipe Tasks SDK를 활용한 온디바이스 스타일 변환</li>
<li>직접 만든 커스텀 스타일 모델 적용<br></li>
</ul>
<p>이 모든 과정을 스스로 해낸 여러분은,<br> <strong>Android on-device AI</strong> 분야에 한 발 더 깊숙히 들어선 것입니다.</p>
<p>진심으로 축하드립니다!</p>
<h2 is-upgraded><strong>🚀 What&#39;s next?</strong></h2>
<p>이제 여러분의 실력을 더 확장해볼 시간입니다.</p>
<h3 is-upgraded><strong>✨ 추천 도전 과제</strong></h3>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>주제</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>설명</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1. MediaPipe 다른 Vision Task 체험하기</p>
</td><td colspan="1" rowspan="1"><p>Object Detection, Hand Tracking, Pose Landmark 등 다양한 Vision 솔루션을 MediaPipe로 직접 구현해보세요.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>2. 실시간 카메라 스트림 적용</p>
</td><td colspan="1" rowspan="1"><p>갤러리 이미지가 아니라, 카메라 실시간 입력에 스타일 변환을 적용해보세요. (약간 난이도 높음)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>3. 커스텀 모델 다양화</p>
</td><td colspan="1" rowspan="1"><p>하나의 스타일이 아니라, 다양한 커스텀 스타일을 전환할 수 있는 앱을 만들어보세요.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>4. 성능 최적화</p>
</td><td colspan="1" rowspan="1"><p>on-device 모델 실행 성능을 분석하고, 처리 속도 향상이나 메모리 최적화를 시도해보세요.</p>
</td></tr>
</table>
<h2 is-upgraded><strong>🧩 추천 예제 실습: MediaPipe 다른 예제 다루기</strong></h2>
<p>아래 MediaPipe Vision Task들도 Android에서 쉽게 사용할 수 있습니다.</p>
<ul>
<li><strong>Object Detector</strong>: 객체 감지 (사진 속 사물을 인식)<br></li>
<li><strong>Hand Landmarker</strong>: 손 관절 검출<br></li>
<li><strong>Pose Landmarker</strong>: 전신 포즈 인식<br></li>
<li><strong>Image Segmenter</strong>: 이미지 배경 분리<br></li>
</ul>
<p>👉<a href="https://github.com/google-ai-edge/mediapipe-samples/tree/main/examples" target="_blank">MediaPipe Samples for Android on GitHub</a></p>
<p>➡️ 관심 있는 Task를 골라, 오늘 배운 흐름처럼 직접 Compose 앱에 적용해보세요.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
